<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Документация проекта</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h2 {
            color: #333;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            overflow-x: auto;
        }
        code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h2>Сборка проекта</h2>
    <ol>
        <li><strong>Сборка проекта</strong>:
            <pre><code>dotnet build</code></pre>
        </li>
        <li><strong>Запуск проекта</strong>:
            <pre><code>dotnet run &lt;путь к файлу&gt;</code></pre>
        </li>
    </ol>

    <h2>AST</h2>
    <p>Синтаксическое дерево (AST) строится путем комбинирования узлов <code>Expr</code> в соответствии с синтаксисом языка программирования. Например, операторы и их операнды объединяются в узлы <code>OPERATOR</code>, условные выражения представляются узлами <code>COND</code>, а функции и их вызовы создают узлы <code>FUNC_DEF</code> и <code>CALL</code> соответственно.</p>
    <p>Каждый узел синтаксического дерева <code>Expr</code> может содержать другие узлы <code>Expr</code>, что позволяет представлять сложные структуры и выражения. Эта структура данных обеспечивает удобное представление синтаксического анализа и интерпретации кода на данном языке программирования.</p>

    <h3>Процесс построения синтаксического дерева</h3>

    <h4>Токенизация</h4>
    <p>Программа принимает исходный код в виде строки и разбивает его на отдельные части, называемые токенами. Этот процесс реализован в функции <code>tokenize</code> модуля <code>Token</code>. Токены представляют собой минимальные единицы синтаксиса, такие как операторы, числа, строки, идентификаторы и специальные символы.</p>

    <h4>Парсинг</h4>
    <p>(Более подробно в разделе <a href="#Парсер">Парсер</a>)</p>
    <p>Следующим шагом является анализ последовательности токенов и построение абстрактного синтаксического дерева (AST). Этот процесс реализован в функции <code>parse</code> модуля <code>Parser</code>. Программа последовательно анализирует каждый токен, сопоставляя его с предопределенными шаблонами, и создает структуры данных <code>Expr</code>, представляющие элементы синтаксического дерева.</p>

    <h4>Создание узлов синтаксического дерева</h4>
    <p>Узлы AST представляются типом <code>Expr</code>, который включает различные виды узлов, такие как:</p>
    <ul>
        <li><strong>SIMPLELIST</strong>: Контейнер для хранения подвыражений, которые нужно вычислить, чтобы получить значение всего выражения. Может содержать как одиночные элементы, такие как числа, так и последовательности операций.</li>
        <li><strong>SIMPLEARGLIST</strong>: Используется для идентификации аргументов функций, заключенных в фигурные скобки <code>{}</code>. Аргументы собираются в одну переменную и помечаются для дальнейшего применения к соответствующим структурным шаблонам.</li>
        <li><strong>SIMPLE</strong>: Служит для определения ключевых слов и поддерживаемых операторов. Представляет собой метку для распознанного типа, полученного из токена.</li>
    </ul>
    <p>На выходе из программы получается дерево синтаксиса, которое представляет структуру введенного выражения.</p>

    <h2>Парсер</h2>
    <p>Парсер программы работает следующим образом:</p>
    <ol>
        <li><strong>Парсинг ключевых слов</strong>:
            <pre><code>| Token.ID(expr)::t when (List.tryFind (fun x -> x = expr) key_words).IsSome -&gt; token_parser (Expr.SIMPLE(expr)::acc) t</code></pre>
        </li>
        <li><strong>Парсинг чисел, строк и логических значений</strong>:
            <pre><code>| Token.NUMBER(n)::t -&gt; token_parser (Expr.SIMPLELIST([Expr.NUMBER(n)])::acc) t
| Token.ID("true")::t -&gt; token_parser (Expr.SIMPLELIST([Expr.BOOL(true)])::acc) t
| Token.ID("false")::t -&gt; token_parser (Expr.SIMPLELIST([Expr.BOOL(false)])::acc) t
| Token.STRING(s)::t -&gt; token_parser (Expr.SIMPLELIST([Expr.STRING(s)])::acc) t</code></pre>
        </li>
        <li><strong>Парсинг идентификаторов</strong>:
            <pre><code>| Token.ID(id)::t -&gt; token_parser (Expr.SIMPLELIST([Expr.ID(id)])::acc) t</code></pre>
        </li>
        <li><strong>Парсинг аргументов функций</strong>:
            <pre><code>| Token.LEFT_CURLY::t -&gt;
    let read_args, remaining_part = token_parser [] t
    if List.forall (fun x -&gt; match x with | Expr.SIMPLELIST([Expr.ID(_)]) -&gt; true | _ -&gt; false) read_args 
    then token_parser (Expr.SIMPLEARGLIST(read_args)::acc) remaining_part
    else failwith ("token_parser ERROR: non ids inside function args: " + (sprintf "%A" read_args))</code></pre>
        </li>
        <li><strong>Парсинг выражений в круглых скобках</strong>:
            <pre><code>| Token.LEFT_PARENTHESIS::t -&gt;
    let read_exprs, remaining_part = token_parser [] t
    match read_exprs with
    | Expr.SIMPLEOP(op)::t -&gt; token_parser (Expr.SIMPLELIST([Expr.OPERATOR(op, t)])::acc) remaining_part
    | Expr.SIMPLE("var")::Expr.SIMPLELIST([Expr.ID(id)])::Expr.SIMPLELIST(list)::[] -&gt; token_parser (Expr.SIMPLELIST([Expr.VARIABLE(id, Expr.SIMPLELIST(list))])::acc) remaining_part
    | Expr.SIMPLE("put")::Expr.SIMPLELIST([Expr.ID(id)])::Expr.SIMPLELIST(list)::[] -&gt; token_parser (Expr.SIMPLELIST([Expr.SET(id, Expr.SIMPLELIST(list))])::acc) remaining_part
    | Expr.SIMPLE("def")::Expr.SIMPLELIST([Expr.ID(id)])::(Expr.SIMPLEARGLIST(args_list) as args)::(Expr.SIMPLELIST(_) as body)::[] -&gt; 
        token_parser (SIMPLELIST([Expr.FUNC_DEF(id, args, body, Map<string, Expr>[], List.length args_list)])::acc) remaining_part
    | Expr.SIMPLELIST([Expr.ID(id)])::t -&gt;
        if List.forall (fun x -&gt; match x with | Expr.SIMPLELIST(_) -&gt; true | _ -&gt; false) t
        then token_parser (SIMPLELIST([Expr.CALL(id, Expr.SIMPLELIST(t), List.length t)])::acc) remaining_part
        else failwith ("token_parser ERROR: wrong function syntax! Used as parameters for function call: " + (sprintf "%A" t)) 
    | Expr.SIMPLELIST(list)::t -&gt; 
        let rec gather_simple_lists acc = function
        | (Expr.SIMPLELIST(_) as list)::t' -&gt; gather_simple_lists (list::acc) t'
        | [] -&gt; List.rev acc, []
        | waste -&gt; 
            printfn "unmatched expr: %A" waste
            failwith "gather_simple_lists ERROR: misformat expression"

        let lists, _ = gather_simple_lists [] (SIMPLELIST(list)::t)
        token_parser (Expr.SIMPLELIST(lists)::acc) remaining_part
    | Expr.SIMPLE("if")::(Expr.SIMPLELIST(_) as cond)
        ::Expr.SIMPLE("then")::(Expr.SIMPLELIST(_) as expr1)
        ::Expr.SIMPLE("else")::(Expr.SIMPLELIST(_) as expr2)::[] -&gt; 
            token_parser (Expr.SIMPLELIST([Expr.COND(cond, expr1, expr2)])::acc) remaining_part
    | Expr.SIMPLE("if")::(Expr.SIMPLELIST(_) as cond)
        ::Expr.SIMPLE("then")::(Expr.SIMPLELIST(_) as expr1)::[] -&gt;
            token_parser (Expr.SIMPLELIST([Expr.COND(cond, expr1, SIMPLE(""))])::acc) remaining_part
    | Expr.SIMPLE("sout")::(Expr.SIMPLELIST(_) as body)::[] -&gt; token_parser (Expr.SIMPLELIST([Expr.PRINT(body)])::acc) remaining_part
    | (Expr.NUMBER(_) as num_expr)::[] -&gt; token_parser (SIMPLELIST([num_expr])::acc) remaining_part
    | (Expr.STRING(_) as str_expr)::[] -&gt; token_parser (SIMPLELIST([str_expr])::acc) remaining_part
    | waste -&gt; failwith ("token_parser ERROR: wrong parenthesis structure: " + (sprintf "%A" waste))</code></pre>
        </li>
        <li><strong>Парсинг операторов</strong>:
            <pre><code>| Token.OPERATOR(op)::t -&gt; token_parser (Expr.SIMPLEOP(op)::acc) t</code></pre>
        </li>
    </ol>

    <h3>Пример использования парсера</h3>
    <p>Рассмотрим следующий пример кода:</p>
    <pre><code>(var fib1 1)
(var fib2 1)
(def fib {n}
  (if (= n 1) 
    fib1 
    (if (= n 2) 
      fib2 
      (+ (fib (- n 1)) (fib (- n 2)))
    )
  )
)
(sout (fib 7))</code></pre>
    <p>Этот код определяет две переменные <code>fib1</code> и <code>fib2</code>, рекурсивную функцию <code>fib</code>, которая вычисляет числа Фибоначчи, и выводит результат вызова этой функции с аргументом 7.</p>

    <h2>Интерпретатор</h2>
    <p>Интерпретатор программы работает следующим образом:</p>
    <ol>
        <li><strong>Интерпретация SIMPLELIST</strong>:
            <pre><code>| Expr.SIMPLELIST(list) -&gt; 
    let rec eval_lists env = function
        | h::t -&gt; 
            let evaluated_first, new_env = eval_impl env h
            match evaluated_first with
            | Expr.SIMPLE(_) as simple -&gt; eval_lists new_env t
            | _ -&gt;
                let evaluated, new_env' = eval_impl new_env evaluated_first 
                match evaluated with
                | Expr.NUMBER(_) | Expr.STRING(_) | Expr.BOOL(_) -&gt; 
                    if List.length t &lt;&gt; 0 then printfn "eval_simple_lists@ warning# useless members at the end of list"
                    evaluated, new_env'
                | _ -&gt; eval_lists new_env' t
        | [] -&gt;
            Expr.SIMPLE(""), env
    eval_lists env list</code></pre>
        </li>
        <li><strong>Интерпретация условного выражения (COND)</strong>:
            <pre><code>| Expr.COND(cond, expr1, expr2) -&gt;
    let eval_cond, new_env = eval_impl env cond
    match eval_cond with 
    | Expr.NUMBER(n) -&gt; if Convert.ToBoolean n then (expr1, new_env) else (expr2, new_env)
    | Expr.BOOL(b) -&gt; if b then (expr1, new_env) else (expr2, new_env)
    | waste -&gt; failwith ("eval_impl ERROR: unevaluatable cond expression: " + (sprintf "%A" waste))</code></pre>
        </li>
        <li><strong>Обращение к именованной переменной</strong>:
            <pre><code>| Expr.ID(id) -&gt; eval_impl env (lookup id env)</code></pre>
        </li>
        <li><strong>Объявление функции (FUNC_DEF)</strong>:
            <pre><code>| Expr.FUNC_DEF(id, args, body, _, arity) -&gt;
    Expr.SIMPLE(""), (Map.add id (Expr.FUNC_DEF(id, args, body, env, arity)) env)</code></pre>
        </li>
        <li><strong>Вызов функции (CALL)</strong>:
            <pre><code>| Expr.CALL(id, Expr.SIMPLELIST(args), arity) -&gt;
    let env_function = Map.tryFind id env
    if env_function.IsNone then failwith ("eval_impl ERROR: use of undeclared function " + id)
    else 
        let (Expr.FUNC_DEF(_, Expr.SIMPLEARGLIST(env_args), body, env_env, env_arity)) = env_function.Value
        if arity &lt;&gt; env_arity 
        then failwith ("eval_impl ERROR: function use with different arity: expected " + (sprintf "%A" env_arity) + " got: " + (sprintf "%A" arity))
        else
            let rec add_env_args env = function
            | (Expr.SIMPLELIST([Expr.ID(h1)])::t1), (h2::t2) -&gt; 
                let eval_h2, new_env =  eval_impl env h2
                add_env_args (Map.add h1 eval_h2 new_env) (t1, t2)
            | ([], []) -&gt; env
            | waste -&gt; failwith ("eval_impl ERROR: Some serious thing happened during concatenations of maps: " + (sprintf "%A" waste))

            let new_env = add_env_args env (env_args, args) 
            let merged_env = Map.fold (fun acc key value -&gt; Map.add key value acc) env new_env
            let merged_env2 = Map.fold (fun acc key value -&gt; Map.add key value acc) merged_env env_env

            eval_impl merged_env2 body</code></pre>
        </li>
        <li><strong>Обработка операторов</strong>:
            <pre><code>| Expr.OPERATOR(op, t) when (Map.tryFind op numeric_operators).IsSome -&gt;
    let (single_lambda, multiple_lambda) = Map.find op numeric_operators
    let evaluated_list, new_env = eval_args_num eval_impl env [] t
    match List.length evaluated_list with
    | 0 -&gt; failwith "eval_impl ERROR: operator + can't have 0 arguments"
    | 1 -&gt; single_lambda (List.head evaluated_list), new_env
    | _ -&gt; List.reduce (fun x y -&gt; multiple_lambda (x, y)) evaluated_list, new_env
| Expr.OPERATOR(op, t) when (Map.tryFind op bool_operators).IsSome -&gt;
    let (single_lambda, multiple_lambda) = Map.find op bool_operators
    let evaluated_list, new_env = eval_args_bool eval_impl env [] t
    match List.length evaluated_list with
    | 0 -&gt; failwith "eval_impl ERROR: operator + can't have 0 arguments"
    | 1 -&gt; single_lambda (List.head evaluated_list), new_env
    | _ -&gt; List.reduce (fun x y -&gt; multiple_lambda (x, y)) evaluated_list, new_env</code></pre>
        </li>
        <li><strong>Простейшие типы</strong>:
            <pre><code>| Expr.NUMBER(_) as number -&gt; number, env
| Expr.STRING(_) as string -&gt; string, env
| Expr.BOOL(_) as boolean -&gt; boolean, env</code></pre>
        </li>
        <li><strong>Печать результатов (PRINT)</strong>:
            <pre><code>| Expr.PRINT(body) -&gt;
    let evaludated_body, new_env = eval_impl env body
    match evaludated_body with
    | Expr.SIMPLE(_) -&gt; failwith ("eval_impl.sout ERROR: unevaluatable simple value to sout\n")
    | _ -&gt;
        let evaluated_eval, new_env' = eval_impl new_env evaludated_body
        match evaluated_eval with
        | Expr.NUMBER(num) -&gt; 
            printfn "%f" num
            SIMPLE(""), new_env
        | Expr.STRING(str) -&gt; 
            printfn "\"%s\"" str
            SIMPLE(""), new_env
        | Expr.BOOL(boolean) -&gt;
            if boolean then
                printfn "true"
                SIMPLE(""), new_env
            else
                printfn "false"
                SIMPLE(""), new_env
        | Expr.ID(id_val) as id -&gt;
            let evaluated_id, new_env'' = eval_impl new_env' id
            printfn "id: %s = %A" id_val evaluated_id
            SIMPLE(""), new_env''</code></pre>
        </li>
    </ol>
    <p>В соответствии с требованиями языка программирования, интерпретатор возвращает один из подтипов <code>Expr</code>. Интерпретатор позволяет анализировать и выполнять код, представленный в структуре дерева синтаксиса.</p>

    <h2>Описание функций</h2>

    <h3>Именованные переменные (let)</h3>
    <p><strong>Описание</strong>: 
        Функция <code>let</code> используется для создания переменных и привязки значений. Это позволяет именовать значения, чтобы затем использовать их в других частях программы.
    </p>
    <p><strong>Синтаксис</strong>:
        <pre><code>(var имя_переменной значение)</code></pre>
    </p>
    <p><strong>Пример</strong>:
        <pre><code>(var x 10)
(sout x)</code></pre>
    </p>
    <p><strong>Пояснение</strong>:
        В данном примере создается переменная <code>x</code> со значением <code>10</code>. Затем значение переменной <code>x</code> выводится с помощью функции <code>sout</code>.
    </p>
    <p><strong>Соответствующий AST</strong>:
        <pre><code>Expr.SIMPLELIST [
    Expr.VARIABLE ("x", Expr.NUMBER 10.0);
    Expr.PRINT (Expr.ID "x")
]</code></pre>
    </p>

    <h3>Рекурсия</h3>
    <p><strong>Описание</strong>: 
        Рекурсия позволяет функции вызывать саму себя. Это полезно для решения задач, которые могут быть разбиты на более мелкие подзадачи того же типа.
    </p>
    <p><strong>Синтаксис</strong>:
        <pre><code>(def имя_функции {аргумент}
  (if (условие)
    (базовый случай)
    (рекурсивный случай)
  )
)</code></pre>
    </p>
    <p><strong>Пример</strong>:
        <pre><code>(def fact {n}
  (if (= n 0)
    1
    (* n (fact (- n 1)))
  )
)
(sout (fact 5))</code></pre>
    </p>
    <p><strong>Пояснение</strong>:
        В данном примере создается функция <code>fact</code>, которая вычисляет факториал числа <code>n</code>. Если <code>n</code> равно 0, функция возвращает 1 (базовый случай). В противном случае возвращается произведение <code>n</code> и вызов <code>fact</code> с аргументом <code>n - 1</code> (рекурсивный случай).
    </p>
    <p><strong>Соответствующий AST</strong>:
        <pre><code>Expr.SIMPLELIST [
    Expr.FUNC_DEF (
        "fact",
        Expr.SIMPLEARGLIST [Expr.SIMPLELIST [Expr.ID "n"]],
        Expr.SIMPLELIST [
            Expr.COND (
                Expr.OPERATOR ("=", [Expr.ID "n"; Expr.NUMBER 0.0]),
                Expr.NUMBER 1.0,
                Expr.OPERATOR ("*", [
                    Expr.ID "n",
                    Expr.CALL ("fact", Expr.SIMPLELIST [Expr.OPERATOR ("-", [Expr.ID "n"; Expr.NUMBER 1.0])], 1)
                ])
            )
        ],
        Map.empty,
        1
    );
    Expr.PRINT (Expr.CALL ("fact", Expr.SIMPLELIST [Expr.NUMBER 5.0], 1))
]</code></pre>
    </p>

    <h3>Ленивое вычисление</h3>
    <p><strong>Описание</strong>: 
        Ленивое вычисление откладывает выполнение выражения до тех пор, пока оно не потребуется. В данной реализации оно используется неявно при интерпретации некоторых выражений.
    </p>

    <h3>Функции</h3>
    <p><strong>Описание</strong>: 
        Функции позволяют группировать повторяющиеся блоки кода для многократного использования.
    </p>
    <p><strong>Синтаксис</strong>:
        <pre><code>(def имя_функции {аргумент1 аргумент2 ...}
  тело_функции
)</code></pre>
    </p>
    <p><strong>Пример</strong>:
        <pre><code>(def add {x y}
  (+ x y)
)
(sout (add 3 5))</code></pre>
    </p>
    <p><strong>Пояснение</strong>:
        В данном примере создается функция <code>add</code>, которая принимает два аргумента <code>x</code> и <code>y</code>, и возвращает их сумму. Затем результат вызова функции <code>add</code> с аргументами <code>3</code> и <code>5</code> выводится с помощью <code>sout</code>.
    </p>
    <p><strong>Соответствующий AST</strong>:
        <pre><code>Expr.SIMPLELIST [
    Expr.FUNC_DEF (
        "add",
        Expr.SIMPLEARGLIST [Expr.SIMPLELIST [Expr.ID "x"]; Expr.SIMPLELIST [Expr.ID "y"]],
        Expr.SIMPLELIST [Expr.OPERATOR ("+", [Expr.ID "x"; Expr.ID "y"])],
        Map.empty,
        2
    );
    Expr.PRINT (Expr.CALL ("add", Expr.SIMPLELIST [Expr.NUMBER 3.0; Expr.NUMBER 5.0], 2))
]</code></pre>
    </p>

    <h3>Замыкания</h3>
    <p><strong>Описание</strong>: 
        Замыкания позволяют функции запоминать окружение, в котором они были созданы. Это полезно для создания функций с состоянием.
    </p>
    <p><strong>Пример</strong>:
        <pre><code>(var x 10)
(def inc {y}
  (+ x y)
)
(sout (inc 5))</code></pre>
    </p>
    <p><strong>Пояснение</strong>:
        В данном примере переменная <code>x</code> находится в окружении функции <code>inc</code>. Когда <code>inc</code> вызывается с аргументом <code>5</code>, она возвращает сумму <code>x</code> и <code>y</code>.
    </p>
    <p><strong>Соответствующий AST</strong>:
        <pre><code>Expr.SIMPLELIST [
    Expr.VARIABLE ("x", Expr.NUMBER 10.0);
    Expr.FUNC_DEF (
        "inc",
        Expr.SIMPLEARGLIST [Expr.SIMPLELIST [Expr.ID "y"]],
        Expr.SIMPLELIST [Expr.OPERATOR ("+", [Expr.ID "x"; Expr.ID "y"])],
        Map.empty,
        1
    );
    Expr.PRINT (Expr.CALL ("inc", Expr.SIMPLELIST [Expr.NUMBER 5.0], 1))
]</code></pre>
    </p>

    <h3>Библиотечные функции: ввод-вывод файлов</h3>
    <p><strong>Описание</strong>: 
        Библиотечные функции для ввода-вывода файлов позволяют считывать данные из файлов и записывать данные в файлы.
    </p>
    <p><strong>Пример</strong>:
        <pre><code>(def readFile {filename}
  ;; читаем файл и возвращаем его содержимое
)

(def writeFile {filename content}
  ;; записываем содержимое в файл
)</code></pre>
    </p>

    <h3>Списки / Последовательности</h3>
    <p><strong>Описание</strong>: 
        Списки и последовательности используются для хранения и работы с коллекциями элементов.
    </p>
    <p><strong>Пример</strong>:
        <pre><code>(var myList [1 2 3 4 5])
(sout (head myList))
(sout (tail myList))</code></pre>
    </p>
    <p><strong>Пояснение</strong>:
        В данном примере создается список <code>myList</code>, затем выводятся его первый элемент (<code>head</code>) и хвост (все элементы, кроме первого, <code>tail</code>).
    </p>

    <h3>Библиотечные функции: списки/последовательности</h3>
    <p><strong>Описание</strong>: 
        Библиотечные функции для работы со списками и последовательностями включают операции, такие как <code>map</code>, <code>filter</code>, <code>reduce</code>.
    </p>
    <p><strong>Пример</strong>:
        <pre><code>(def map {f lst}
  ;; применяем функцию f к каждому элементу списка lst
)</code></pre>
    </p>
</body>
</html>